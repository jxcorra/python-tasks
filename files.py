EX_FILE_NAME = 'data.txt'

# открытие файла на запись
with open(EX_FILE_NAME, 'w', encoding='utf-8') as f:
    # используя `write`
    f.write('First line\n')

    # используя `writelines`
    several_lines = [
        'Second line\n',
        'Third line\n',
        'Fourth line\n'
    ]
    f.writelines(several_lines)

    # сброс internal buffer на уровень операционной системы.
    # будет неявно вызыван при закрытии файла используя `close`
    # или выходя за пределы контекстного менеджера

    # os                ^
    # os buffer         |
    # internal buffer   |
    # python            |
    f.flush()

    # узнать путь открытого файла
    print(f'File path: {f.name}')

    # узнать режим открытого файла
    print(f'File mode: {f.mode}')

    # узнать кодировку файла
    print(f'File encoding is {f.encoding}')

    # узнать закрыт ли файл
    print(f'Is file closed? {f.closed}')


# открытие файла в байтовом режиме на запись
# байтовый `b` означает, что мы работаем теперь не просто с текстом
# а с закодированным текстом
# то есть перед записью в файл, python ожидает, что текст будет закодирован
# text -> encode -> bytes
# если посмотреть на содержимое файла, то можно увидеть там вполне себе читаемый текст,
# но это происходит по причине того, что сам текстовый редактор раскодирует байты для отображения
with open(EX_FILE_NAME, 'wb') as f:
    # данные требуется вручную кодировать в байты:
    # текст -> кодирование -> байты -> декодирование -> текст

    # используя `write`
    f.write('Первая строка\n'.encode('utf-8'))

    # используя `writelines`
    several_lines = [
        'Вторая строка\n'.encode('utf-8'),
        'Третья строка\n'.encode('utf-8'),
        'Четвертая строка\n'.encode('utf-8')
    ]
    f.writelines(several_lines)

    # сброс internal buffer на уровень операционной системы.
    # будет неявно вызыван при закрытии файла используя `close`
    # или выходя за пределы контекстного менеджера

    # os                ^
    # os buffer         |
    # internal buffer   |
    # python            |
    f.flush()

    # узнать путь открытого файла
    print(f'File path: {f.name}')

    # узнать режим открытого файла
    print(f'File mode: {f.mode}')

    # узнать кодировку файла у файла, открытого в байтовом режиме, не выйдет
    try:
        print(f'File encoding is {f.encoding}')
    except AttributeError:
        print(f'No `encoding` attribute')

    # узнать закрыт ли файл
    print(f'Is file closed? {f.closed}')


# открытие файла на чтение
with open(EX_FILE_NAME, 'r', encoding='utf-8') as f:
    # используя `read` при работе не в байтовом режиме
    # в `read` можно передать кол-во символов, которые необходимо прочесть
    # если не указать кол-во, то будет прочитано максимальное кол-во данных,
    # которое можно уместить в оператирной памяти
    text_chunk = f.read(10)
    print(f'Part of file: {text_chunk}')

    # `read` сдвигает тот самый "курсор" в файле, то есть прочитав 10 символов
    # при следующем чтении уже будет прочитана часть файла, не включая первые 10 символов
    text = f.read()
    print(f'Second part of file: {text}')

    # `seek` позволяет нам отмотать курсор в файле на указанную позицию
    # в данном случае 0 переведет курсор в начало файла, так как
    # `seek` принимает 2 аргумента: `offset`, `whence`, где
    # `offset` - позиция в байтах (не в символах), иногда 1 символ может быть представлен несколькими байтами
    # `whence` - откуда начинать отсчет (по умолчанию 0):
    # 0 - начало файла
    # 1 - текущая позиция (с текущей позиции курсора)
    # 2 - конец файла
    # используя, например, f.seek(-5, 2) можно переместить курсор на 5 байтов до конца файла,
    # а f.seek(10) переместит на 10 байт от начала файла (второй аргумент не указан, так как по умолчанию 0)
    f.seek(0)  # отматываем файл в начало

    # чтение используя `for`
    for line in f:
        print(line)

    f.seek(0)  # отматываем файл в начало

    # чтение используя `readlines`
    # возвращает строки файла списком
    lines = f.readlines()
    print(lines)

    f.seek(0)

    # прочтет только одну строку
    line = f.readline()
    print(line)

    # узнать путь открытого файла
    print(f'File path: {f.name}')

    # узнать режим открытого файла
    print(f'File mode: {f.mode}')

    # узнать кодировку файла у файла, открытого в байтовом режиме, не выйдет
    try:
        print(f'File encoding is {f.encoding}')
    except AttributeError:
        print(f'No `encoding` attribute')

    # узнать закрыт ли файл
    print(f'Is file closed? {f.closed}')

# открытие файла на чтение в байтовом режиме
with open(EX_FILE_NAME, 'rb') as f:
    # используя `read` при работе в байтовом режиме
    # в `read` можно передать кол-во байт, которые необходимо прочесть
    # если не указать кол-во, то будет прочитано максимальное кол-во данных,
    # которое можно уместить в оператирной памяти
    text_chunk = f.read(10)
    # теперь, так как мы читаем байты, мы должны декодировать их используя кодировку и
    # метод `decode`. попробуйте убрать `decode` и посмотрите что выведется в консоль
    print(f'Part of file: {text_chunk.decode("utf-8")}')

    # `read` сдвигает тот самый "курсор" в файле, то есть прочитав 10 байт
    # при следующем чтении уже будет прочитана часть файла, не включая первые 10 байт
    text = f.read()
    print(f'Second part of file: {text.decode("utf-8")}')

    # `seek` позволяет нам отмотать курсор в файле на указанную позицию
    # в данном случае 0 переведет курсор в начало файла, так как
    # `seek` принимает 2 аргумента: `offset`, `whence`, где
    # `offset` - позиция в байтах (не в символах), иногда 1 символ может быть представлен несколькими байтами
    # `whence` - откуда начинать отсчет (по умолчанию 0):
    # 0 - начало файла
    # 1 - текущая позиция (с текущей позиции курсора)
    # 2 - конец файла
    # используя, например, f.seek(-5, 2) можно переместить курсор на 5 байтов до конца файла,
    # а f.seek(10) переместит на 10 байт от начала файла (второй аргумент не указан, так как по умолчанию 0)
    f.seek(0)  # отматываем файл в начало

    # чтение используя `for`
    for line in f:
        print(line.decode('utf-8'))

    f.seek(0)  # отматываем файл в начало

    # чтение используя `readlines`
    # возвращает строки файла списком
    lines = f.readlines()
    decoded_lines = [line.decode('utf-8') for line in lines]
    print(decoded_lines)

    f.seek(0)

    # прочтет только одну строку
    line = f.readline().decode('utf-8')
    print(line)

    # обратите внимание на ошибку
    # курсор был сдвинут на 7 байт от начала файла
    # но в utf-8 на 1 символ выделяется 2 и более байт, то есть прочитав
    # нечетное количество мы по сути прочтем 3.5 символа - такого не бывает
    # прочитав из файла 3 байта мы не сможем раскодировать их в 1.5 символа и получим ошибку
    try:
        f.seek(7)
        chunk = f.read(3)
        print(chunk.decode('utf-8'))
    except UnicodeDecodeError:
        print('Exception during decoding partial bytes')

    # `tell` может нам сообщить текущую позицию курсора в файле в байтах
    current_position_in_file = f.tell()
    print(f'Current position: {current_position_in_file}')

    # узнать путь открытого файла
    print(f'File path: {f.name}')

    # узнать режим открытого файла
    print(f'File mode: {f.mode}')

    # узнать кодировку файла у файла, открытого в байтовом режиме, не выйдет
    try:
        print(f'File encoding is {f.encoding}')
    except AttributeError:
        print(f'No `encoding` attribute')

    # узнать закрыт ли файл
    print(f'Is file closed? {f.closed}')
